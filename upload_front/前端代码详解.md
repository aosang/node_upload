# 前端图片上传代码详解（初学者版）

> 💡 **阅读提示**：本文档按照代码执行顺序讲解，每个步骤都有通俗易懂的比喻，适合前端初学者理解。

## 📚 目录
1. [功能概览](#功能概览)
2. [整体流程图](#整体流程图)
3. [页面结构 (HTML模板)](#页面结构-html模板)
4. [数据定义](#数据定义)
5. [代码执行顺序详解](#代码执行顺序详解)
6. [前后端交互流程](#前后端交互流程)
7. [常见问题](#常见问题)

---

## 功能概览

这是一个**图片上传组件**，实现了以下功能：

| 功能 | 说明 | 好处 |
|------|------|------|
| 📸 **自动压缩** | 所有图片上传前都会压缩 | 节省流量，上传更快 |
| 📦 **分块上传** | 大文件切成1MB小块上传 | 网络中断不用重头开始 |
| 🔄 **断点续传** | 刷新页面后可以继续上传 | 不浪费已上传的部分 |
| 🔁 **失败重试** | 上传失败自动重试3次 | 提高上传成功率 |
| ⚡ **并发控制** | 最多3个文件同时上传 | 避免占用太多带宽 |
| 🎯 **重复检测** | 已上传的文件不会重复上传 | 节省时间和资源 |
| 🔒 **文件完整性** | 双重验证确保文件真实存在 | 数据可靠性高 |

---

## 整体流程图

```
👤 用户操作                    💻 程序执行                      🌐 后端交互
    │                             │                              │
    ├─ 1. 点击"选择文件"            │                              │
    │                             │                              │
    ├─ 2. 选择图片                 │                              │
    │                             ├─ handleFileChange            │
    │                             │  (记录文件信息)                │
    │                             │                              │
    ├─ 3. 点击"开始上传"            │                              │
    │                             ├─ startUpload                 │
    │                             │  ↓                           │
    │                             ├─ beforeUpload                │
    │                             │  ├─ 检查文件大小              │
    │                             │  └─ Worker压缩图片            │
    │                             │     (500KB → 100KB)          │
    │                             │  ↓                           │
    │                             ├─ customHttpRequest           │
    │                             │  (加入上传队列)               │
    │                             │  ↓                           │
    │                             ├─ processQueue                │
    │                             │  (控制并发数)                 │
    │                             │  ↓                           │
    │                             ├─ uploadFileWithChunks        │
    │                             │  ├─ 生成文件ID                │
    │                             │  ├─ 读取断点记录              │
    │                             │  ├─ 🔍 检查是否已完成          │
    │                             │  │  ├─ 调用后端验证           │
    │                             │  │  ├─ 已完成 → 直接跳过 ✅   │
    │                             │  │  └─ 不存在 → 重新上传 ♻️  │
    │                             │  ├─ 切割文件(1MB/块)          │
    │                             │  ├─ 上传分块 ─────────────────> POST /upload-chunk
    │                             │  │  (重试3次)                 │  (接收分块)
    │                             │  ├─ 保存进度到localStorage   │
    │                             │  ├─ 🎯 清理localStorage       │
    │                             │  └─ 合并文件 ─────────────────> POST /merge-chunks
    │                             │                              │  ├─ 检查完成标记
    │                             │                              │  ├─ 验证文件存在
    │                             │                              │  └─ 合并所有分块
    │                             │  ↓                           │  ↓
    ├─ 4. 看到进度条              │  显示进度 0% → 100%           │  ✓ 文件保存成功
    │                             │  ↓                           │
    └─ 5. 显示"上传成功" ✓        └─ ElMessage.success           │
```

---

## 页面结构 (HTML模板)

### 1. 文件选择按钮

```vue
<el-upload 
  ref="uploadRef"                  <!-- 给组件起个"名字"，JS中可以用这个名字控制它 -->
  multiple                         <!-- 允许一次选多个文件 -->
  :before-upload="beforeUpload"    <!-- 上传前先执行这个函数（检查+压缩） -->
  :http-request="customHttpRequest" <!-- 自定义上传方式（不用默认的） -->
  :file-list="fileList"            <!-- 显示已选择的文件列表 -->
  :auto-upload="false"             <!-- 不要自动上传，等我点"开始上传"按钮 -->
  :on-change="handleFileChange"    <!-- 选择文件后执行这个函数 -->
>
  <el-button type="primary">批量上传图片</el-button>
</el-upload>
```

**通俗理解**：
```
这就像一个"文件选择器"：
- multiple：可以同时选多个文件（像购物车可以加多个商品）
- auto-upload="false"：选完文件不会立即上传，要等你点"开始上传"
- before-upload：上传前的"检查站"，确保文件符合要求
- http-request：自定义上传方式（我们要分块上传，不用默认的一次性上传）
```

### 2. 开始上传按钮

```vue
<el-button 
  type="primary" 
  @click="startUpload"                   <!-- 点击时执行 startUpload 函数 -->
  :disabled="fileList.length === 0"      <!-- 没选文件时禁用（灰色不可点击） -->
>
  开始上传
</el-button>
```

**通俗理解**：
```
就像"结账"按钮：
- 购物车空的（fileList.length === 0）→ 按钮灰色不能点
- 购物车有东西 → 按钮可点击，开始上传
```

### 3. 进度显示区域

```vue
<div v-for="file in uploadStatus" :key="file.uid">
  <!-- 文件名和状态 -->
  <div>
    <span>{{ file.name }}</span>  <!-- test.jpg -->
    <span v-if="file.status === 'success'">✓ 上传成功</span>
    <span v-if="file.status === 'error'">✗ 上传失败</span>
  </div>
  
  <!-- 进度条 -->
  <el-progress 
    :percentage="Math.floor(file.progress)"  <!-- 进度：0 到 100 -->
    :status="file.status === 'success' ? 'success' : ..."
  />
</div>
```

**通俗理解**：
```
就像快递追踪：
- file.progress: 0%     → "商家已发货"
- file.progress: 50%    → "运输中"
- file.progress: 100%   → "已签收" ✓
- file.status: 'error'  → "派送失败" ✗
```

---

## 数据定义

### 引入的工具

```javascript
import { ref, onMounted, onUnmounted } from 'vue'  // Vue 3 的工具
import { ElMessage } from 'element-plus'            // 消息提示（成功/失败弹窗）
import request from '@/utils/request'               // HTTP请求工具（与后端通信）
```

**ref 是什么？**
```javascript
// ref() 让变量变成"响应式"的：
const count = ref(0)      // 创建响应式变量

count.value = 1           // 修改变量
// → 页面自动更新，显示新的值

// 类似于 Excel：
// 单元格A1 = 10
// 单元格B1 = A1 * 2
// 修改A1 = 20 → B1自动变成40
```

### 响应式数据

```javascript
const fileList = ref([])        // 用户选择的文件列表
const uploadStatus = ref([])    // 每个文件的上传状态（进度、成功/失败）
const uploadRef = ref(null)     // 上传组件的引用（用来控制组件）
```

**示例数据**：
```javascript
// fileList 的内容：
[
  { uid: '123', name: 'photo1.jpg', size: 500000 },
  { uid: '456', name: 'photo2.jpg', size: 800000 }
]

// uploadStatus 的内容：
[
  { uid: '123', name: 'photo1.jpg', progress: 50, status: 'uploading' },
  { uid: '456', name: 'photo2.jpg', progress: 0, status: 'pending' }
]
```

### 普通变量

```javascript
let uploadQueue = []        // 上传队列（排队等待上传的文件）
let currentUploads = 0      // 当前正在上传的文件数（最多3个）
let worker = null           // Worker线程（专门用来压缩图片）
```

**为什么要队列？**
```
假设同时选了5个文件：

┌─────────────────┐
│  uploadQueue    │ (队列)
├─────────────────┤
│ file1 [上传中]  │ ← 正在上传
│ file2 [上传中]  │ ← 正在上传
│ file3 [上传中]  │ ← 正在上传
│ file4           │ ← 等待
│ file5           │ ← 等待
└─────────────────┘

最多3个同时上传 (currentUploads = 3)
file4, file5 在队列中等待
file1 完成后，file4 开始上传
```

### 配置参数

```javascript
const maxConcurrentUploads = 3         // 最多同时上传3个文件
const maxSizeInMB = 100                // 文件最大100MB
const CHUNK_SIZE = 1 * 1024 * 1024     // 分块大小：1MB
```

**为什么是 1024？**
```
计算机用二进制：
1KB = 1024 字节 (不是1000)
1MB = 1024 KB = 1024 × 1024 = 1048576 字节
```

---

## 代码执行顺序详解

> 📝 **重要**：按照用户操作的顺序讲解，每一步都有详细说明。

---

### 步骤0：页面加载时（初始化）

```javascript
// ==================== 生命周期钩子 ====================

/**
 * 组件挂载时初始化 Worker
 * 时机：页面刚打开时自动执行
 */
onMounted(() => {
  // 创建 Worker 线程（专门用来压缩图片）
  worker = new Worker(new URL('@/utils/imageWorker.js', import.meta.url))
  console.log('Worker 已初始化')
})
```

**Worker 是什么？**
```
Worker 就像雇一个"助手"：

主线程（你）：
  - 负责页面交互（点击按钮、更新进度条）
  - 不能被阻塞（否则页面卡死）

Worker（助手）：
  - 在后台压缩图片
  - 不影响页面操作
  - 压缩完成后通知主线程

好处：
  ✅ 压缩图片时，页面不会卡顿
  ✅ 用户可以继续操作页面
```

---

### 步骤1：用户选择文件

**用户操作**：点击"批量上传图片"按钮 → 选择文件 → 点击"打开"

**代码执行**：

```javascript
// ==================== 流程1：文件选择 ====================

/**
 * 文件选择变化时触发
 * 时机：用户选择文件后
 * 作用：记录选择的文件，准备上传
 */
const handleFileChange = (file, fileListData) => {
  // 更新文件列表
  fileList.value = fileListData
  
  // 检查这个文件是否已经在上传状态列表中
  const exists = uploadStatus.value.find(item => item.uid === file.uid)
  
  // 如果不存在，添加到上传状态列表
  if (!exists) {
    uploadStatus.value.push({
      uid: file.uid,         // 文件唯一ID（Element Plus自动生成）
      name: file.name,       // 文件名（例如：photo.jpg）
      progress: 0,           // 进度：0%
      status: 'pending'      // 状态：等待中
    })
  }
}
```

**通俗理解**：
```
就像加购物车：
1. 你选了一个商品（文件）
2. 检查购物车里有没有这个商品（exists）
3. 如果没有，添加到购物车（push）
4. 记录商品信息：名字、数量、状态
```

**file.uid 是什么？**
```javascript
// Element Plus 自动给每个文件生成的唯一ID
file.uid = "1704067200123"  // 类似订单号

// 用途：区分不同的文件
photo1.jpg → uid: "123"
photo2.jpg → uid: "456"
```

---

### 步骤2：用户点击"开始上传"

**用户操作**：点击"开始上传"按钮

**代码执行**：

```javascript
// ==================== 流程6：开始上传 ====================

/**
 * 点击"开始上传"按钮时触发
 * 时机：用户点击按钮
 * 作用：提交所有文件开始上传流程
 */
const startUpload = () => {
  if (uploadRef.value) {
    uploadRef.value.submit()  // 触发 el-upload 的提交方法
  }
}
```

**uploadRef 是什么？**
```vue
<!-- HTML 中给组件起名字： -->
<el-upload ref="uploadRef">

<!-- JS 中可以通过这个名字控制组件： -->
const uploadRef = ref(null)
uploadRef.value.submit()    // 调用组件的 submit 方法

// 类似于：
遥控器（uploadRef） → 控制电视（el-upload组件）
按按钮（submit） → 电视开始工作
```

**submit() 会做什么？**
```
el-upload 的 submit() 方法会：
1. 遍历所有选择的文件
2. 对每个文件执行 before-upload（检查+压缩）
3. 然后执行 http-request（上传）
```

---

### 步骤3：上传前处理（压缩）

**代码执行**：submit() → beforeUpload()

```javascript
// ==================== 流程2：上传前处理（压缩） ====================

/**
 * 上传前处理：所有图片都进行压缩
 * 时机：在上传前自动调用
 * 作用：检查文件大小 + 压缩图片
 * 返回：Promise（异步操作）
 */
const beforeUpload = (file) => {
  // ========== 第1步：检查文件大小 ==========
  const isUnderLimit = file.size / 1024 / 1024 < maxSizeInMB
  if (!isUnderLimit) {
    ElMessage.error(`文件大小不能超过${maxSizeInMB}MB`)
    return false  // 返回 false，阻止上传
  }

  // ========== 第2步：压缩图片 ==========
  // 所有图片都使用 Worker 压缩（无论大小）
  if (worker) {
    return new Promise((resolve, reject) => {
      // 生成唯一任务ID（避免多文件同时压缩时混乱）
      const taskId = `${file.name}_${file.size}_${Date.now()}_${Math.random()}`
      
      const handleMessage = (event) => {
        // 检查是否是当前任务的响应
        if (event.data.taskId === taskId) {
          worker.removeEventListener('message', handleMessage)
          worker.removeEventListener('error', handleError)
          
          if (event.data.success) {
            const compressedFile = event.data.file
            
            // 🎯 关键：给压缩后的文件添加原始文件信息
            // 这样可以确保文件ID的唯一性和一致性
            compressedFile._originalFile = {
              name: file.name,
              size: file.size,
              lastModified: file.lastModified
            }
            
            console.log(`[${file.name}] 压缩完成: ${file.size} -> ${compressedFile.size} 字节`)
            resolve(compressedFile)
          } else {
            console.error(`[${file.name}] 压缩失败:`, event.data.error)
            reject(new Error(event.data.error))
          }
        }
      }

      const handleError = (error) => {
        worker.removeEventListener('message', handleMessage)
        worker.removeEventListener('error', handleError)
        console.error(`[${file.name}] Worker 错误:`, error)
        reject(error)
      }

      worker.addEventListener('message', handleMessage)
      worker.addEventListener('error', handleError)
      
      worker.postMessage({ 
        file, 
        quality: 0.8,           // 压缩质量 0.8
        targetFormat: 'jpeg',   // 目标格式 JPEG
        taskId                  // 传递任务ID
      })
    })
  }

  return true
}
```

**为什么需要 taskId？**
```
问题场景：同时压缩3个文件

没有 taskId：
photo1.jpg → Worker → 返回结果
photo2.jpg → Worker → 返回结果
photo3.jpg → Worker → 返回结果

❌ 3个 handleMessage 都收到第一个结果，分不清是谁的！
❌ 导致3个文件都被当成同一个压缩结果

有 taskId：
photo1.jpg → Worker (taskId: abc) → 返回结果 (taskId: abc)
photo2.jpg → Worker (taskId: def) → 返回结果 (taskId: def)
photo3.jpg → Worker (taskId: ghi) → 返回结果 (taskId: ghi)

✅ 每个 handleMessage 只处理自己的 taskId
✅ 不会混乱
```

**为什么保存 _originalFile？**
```
原始文件：
photo.jpg
  - name: "photo.jpg"
  - size: 500000
  - lastModified: 1704067200000

压缩后：
compressed.blob
  - name: "blob"           ← 文件名变了
  - size: 100000           ← 大小变了

问题：
不同的原始文件可能压缩成相同大小！
photo1.jpg (500KB) → 压缩 → 100KB
photo2.jpg (520KB) → 压缩 → 100KB  ← 大小相同！

如果用压缩后的信息生成ID：
❌ 不同文件产生相同ID，会互相覆盖！

解决方案：
保存原始文件信息，用原始信息生成ID：
✅ photo1.jpg → "photo1.jpg_500000_1704067200000"
✅ photo2.jpg → "photo2.jpg_520000_1704067300000"
```

---

### 步骤4：加入上传队列

**代码执行**：beforeUpload() 完成 → customHttpRequest()

```javascript
// ==================== 流程3：自定义上传（加入队列） ====================

/**
 * 自定义上传请求处理
 * 时机：beforeUpload 完成后自动调用
 * 作用：将文件加入队列，控制并发上传数量
 */
const customHttpRequest = (options) => {
  const { file, onProgress, onError, onSuccess } = options
  
  // 将文件和回调函数包装到队列中
  uploadQueue.push({
    file,           // 文件对象（可能是压缩后的）
    onProgress,     // 进度回调（用来更新进度条）
    onError,        // 错误回调（上传失败时调用）
    onSuccess,      // 成功回调（上传成功时调用）
    uid: file.uid   // 文件唯一ID
  })
  
  // 开始处理队列
  processQueue()
}
```

---

### 步骤5：处理上传队列

**代码执行**：customHttpRequest() → processQueue()

```javascript
// ==================== 流程4：处理上传队列 ====================

/**
 * 处理上传队列
 * 时机：队列中有文件时自动调用
 * 作用：根据最大并发数，从队列中取出文件进行上传
 */
const processQueue = () => {
  // while 循环：当满足条件时，一直执行
  // 条件1：当前上传数 < 3
  // 条件2：队列中还有文件
  while (currentUploads < maxConcurrentUploads && uploadQueue.length > 0) {
    const nextFile = uploadQueue.shift()  // 从队列头部取出一个文件
    if (nextFile) {
      uploadFileWithChunks(nextFile)      // 开始上传
    }
  }
}
```

**通俗理解**：
```
就像银行柜台：

┌──────────────────┐
│  3个柜台（窗口）  │
├──────────────────┤
│ 柜台1: [正在办理] │ ← currentUploads = 3
│ 柜台2: [正在办理] │
│ 柜台3: [正在办理] │
└──────────────────┘

┌──────────────────┐
│  排队区          │
├──────────────────┤
│ 顾客A: [等待]    │ ← uploadQueue
│ 顾客B: [等待]    │
└──────────────────┘

processQueue 的工作：
1. 检查是否有空闲柜台 (currentUploads < 3)
2. 如果有，叫下一位顾客 (shift)
3. 开始办理业务 (uploadFileWithChunks)
```

---

### 步骤6：分块上传（核心！⭐）

这是**最重要的函数**，负责整个上传过程：

#### 6.1 准备阶段

```javascript
const uploadFileWithChunks = async (fileData) => {
  currentUploads++  // 占用一个"柜台"
  const file = fileData.file
  
  // 获取文件名（使用原始文件名）
  const fileName = file._originalFile ? file._originalFile.name : file.name
  
  // 生成文件ID（使用原始文件信息确保唯一性）
  const fileId = getFileIdentifier(file)
  
  console.log(`[${fileName}] 开始上传`)
  console.log(`[${fileName}] 文件ID: ${fileId}`)
```

#### 6.2 生成唯一文件ID

```javascript
/**
 * 生成文件的唯一标识
 * 规则：文件名_文件大小_最后修改时间
 */
const getFileIdentifier = (file) => {
  const originalFile = file._originalFile || file
  const safeName = originalFile.name.replace(/[^a-zA-Z0-9.-]/g, '_')
  return `${safeName}_${originalFile.size}_${originalFile.lastModified}`
}
```

**为什么这样生成ID？**
```
示例：

文件A: photo1.jpg (500KB, 修改时间: 1704067200000)
  → ID: "photo1.jpg_500000_1704067200000"

文件B: photo2.jpg (800KB, 修改时间: 1704067300000)
  → ID: "photo2.jpg_800000_1704067300000"  ← 不同的ID ✅

文件C: photo1.jpg (完全相同的文件)
  → ID: "photo1.jpg_500000_1704067200000"  ← 相同的ID ✅

作用：
1. 不同文件 → 不同ID → 不会冲突
2. 相同文件 → 相同ID → 可以断点续传
3. 前后端用相同ID识别文件
```

#### 6.3 读取断点记录

```javascript
// 从 localStorage 读取已上传的分块
const progressKey = `upload_${fileId}`
let uploadedChunks = []

try {
  const saved = localStorage.getItem(progressKey)
  if (saved) {
    uploadedChunks = JSON.parse(saved).chunks || []
    console.log(`[${fileName}] 发现断点，已上传 ${uploadedChunks.length} 块`)
  }
} catch (e) {
  console.log(`[${fileName}] 无断点记录，从头开始`)
}
```

**断点续传原理**：
```
第一次上传（上传到一半）：
上传分块 0 → localStorage: {"chunks":[0]}
上传分块 1 → localStorage: {"chunks":[0,1]}
（用户刷新页面）

第二次上传（继续）：
读取 localStorage → uploadedChunks = [0, 1]
跳过分块 0, 1 (已上传)
从分块 2 开始上传 ✅
```

#### 6.4 文件完成验证（重要优化！🎯）

```javascript
// 🎯 检查是否所有分块都已上传
if (uploadedChunks.length === totalChunks) {
  console.log(`[${fileName}] 本地记录显示文件已完成，尝试合并验证...`)
  
  try {
    // 🔍 调用后端验证文件是否真实存在
    await request.post('/merge-chunks', {
      filename: fileName,
      fileId: fileId,
      totalChunks
    })
    
    // 文件确实存在，跳过重复上传
    console.log(`[${fileName}] ✓ 文件已存在，跳过重复上传`)
    localStorage.removeItem(progressKey)
    currentUploads--
    processQueue()
    fileData.onSuccess({ success: true })
    updateUploadProgress(fileData.uid, 100, 'success')
    ElMessage.success(`${fileName} 已上传（跳过重复上传）`)
    return
    
  } catch (error) {
    // 验证失败，清理记录重新上传
    console.log(`[${fileName}] ⚠️ 验证失败，清理本地记录重新上传`)
    localStorage.removeItem(progressKey)
    uploadedChunks = []
  }
}
```

**为什么需要验证？**
```
场景1：文件已上传完成
  localStorage: {"chunks":[0,1,2,3,4]} ✓
  后端: uploads/photo.jpg ✓
  → 验证成功 → 跳过重复上传 ✅

场景2：后端文件被删除
  localStorage: {"chunks":[0,1,2,3,4]} ✓
  后端: 文件不存在 ✗
  → 验证失败 → 清理记录 → 重新上传 ♻️

好处：
✅ 避免重复上传
✅ 自动检测文件是否真实存在
✅ 提供完整性保障
```

#### 6.5 逐个上传分块

```javascript
for (let i = 0; i < totalChunks; i++) {
  // 跳过已上传的分块
  if (uploadedChunks.includes(i)) {
    console.log(`[${fileName}] 分块 ${i} 已上传，跳过`)
    const progress = ((i + 1) / totalChunks) * 100
    updateUploadProgress(fileData.uid, progress, 'uploading')
    continue
  }
  
  // 切割分块
  const start = i * CHUNK_SIZE
  const end = Math.min(start + CHUNK_SIZE, file.size)
  const chunk = file.slice(start, end)
  
  // 准备FormData
  const formData = new FormData()
  formData.append('chunk', chunk)
  formData.append('filename', fileName)
  formData.append('fileId', fileId)
  formData.append('chunkNumber', i)
  formData.append('totalChunks', totalChunks)
  
  // 上传（重试3次）
  let success = false
  for (let retry = 0; retry < 3 && !success; retry++) {
    try {
      await request.post('/upload-chunk', formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      })
      success = true
      
      // 记录到 localStorage
      uploadedChunks.push(i)
      localStorage.setItem(progressKey, JSON.stringify({ chunks: uploadedChunks }))
      
      // 更新进度
      const progress = ((i + 1) / totalChunks) * 100
      updateUploadProgress(fileData.uid, progress, 'uploading')
      fileData.onProgress({ percent: progress })
      
    } catch (error) {
      if (retry < 2) {
        console.log(`[${fileName}] 分块 ${i} 上传失败，重试 ${retry + 1}/3`)
        await new Promise(resolve => setTimeout(resolve, 1000))
      } else {
        throw new Error(`分块 ${i} 上传失败`)
      }
    }
  }
}
```

#### 6.6 合并文件

```javascript
// 🎯 所有分块上传完成后，立即清理 localStorage
console.log(`[${fileName}] 所有分块上传完成，清理断点记录`)
localStorage.removeItem(progressKey)

// 调用后端合并接口
console.log(`[${fileName}] 开始合并...`)
try {
  await request.post('/merge-chunks', {
    filename: fileName,
    fileId: fileId,
    totalChunks
  })
  
  console.log(`[${fileName}] ✓ 合并完成`)
  currentUploads--
  processQueue()
  fileData.onSuccess({ success: true })
  updateUploadProgress(fileData.uid, 100, 'success')
  ElMessage.success(`${fileName} 上传成功`)
  
} catch (mergeError) {
  // 容错处理
  const errorMsg = mergeError.message || ''
  
  if (errorMsg.includes('分块目录不存在') || errorMsg.includes('不存在')) {
    // 所有分块已上传，但临时目录被清理，视为成功
    console.log(`[${fileName}] ⚠️ 分块目录不存在，但所有分块已上传完成（容错处理）`)
    currentUploads--
    processQueue()
    fileData.onSuccess({ success: true })
    updateUploadProgress(fileData.uid, 100, 'success')
    ElMessage.success(`${fileName} 上传成功`)
  } else {
    throw mergeError
  }
}
```

**为什么立即清理 localStorage？**
```
旧逻辑：
所有分块上传完成 → 调用合并接口 → 合并成功 → 清理 localStorage

问题：
如果用户在合并前刷新页面：
  localStorage 还有记录 → 再次上传会出错 ❌

新逻辑：
所有分块上传完成 → 立即清理 localStorage → 调用合并接口

优点：
✅ 即使用户刷新，localStorage 也已清理
✅ 避免重复上传问题
✅ 更加健壮
```

---

### 步骤7：组件卸载时清理

```javascript
/**
 * 组件卸载时清理 Worker
 */
onUnmounted(() => {
  if (worker) {
    worker.terminate()  // 终止 Worker 线程
    worker = null
    console.log('Worker 已清理')
  }
})
```

---

## 前后端交互流程

### 完整的数据流

```
1. 用户选择文件
   ↓
2. 前端：Worker 压缩文件 (500KB → 100KB)
   ↓
3. 前端：切割成分块 (每块1MB)
   ↓
┌──────────────────────┐
│  分块 0 (1MB)         │ ──→ POST /upload-chunk ──→ 后端保存 temp_chunks/fileId/chunk-0
│  分块 1 (1MB)         │ ──→ POST /upload-chunk ──→ 后端保存 temp_chunks/fileId/chunk-1
│  分块 2 (0.5MB)       │ ──→ POST /upload-chunk ──→ 后端保存 temp_chunks/fileId/chunk-2
└──────────────────────┘
   ↓
4. 所有分块上传完成
   ↓
5. 前端：清理 localStorage
   ↓
6. 前端：POST /merge-chunks
   ↓
   后端：
     ├─ 检查完成标记（是否已上传过）
     ├─ 验证文件存在（双重验证）
     ├─ 读取所有分块
     ├─ 合并成完整文件 → uploads/photo-xxx.jpg
     ├─ 删除临时分块目录
     └─ 创建完成标记 → upload_completed/fileId
   ↓
7. 后端返回：{ success: true, filename: "photo-xxx.jpg" }
   ↓
8. 前端显示："上传成功" ✅
```

### 断点续传流程

```
第一次上传（网络中断）：
上传分块 0 ✓ → localStorage: {"chunks":[0]}
上传分块 1 ✓ → localStorage: {"chunks":[0,1]}
上传分块 2 ... (网络中断)

第二次上传（继续）：
读取 localStorage → uploadedChunks = [0, 1]
跳过分块 0 ✓ (已上传)
跳过分块 1 ✓ (已上传)
上传分块 2 ✓ → localStorage: {"chunks":[0,1,2]}
合并文件 ✓
清理 localStorage
```

### 重复上传检测流程

```
第一次上传：
photo.jpg → 上传完成 ✓
后端：
  - uploads/photo-xxx.jpg (文件保存)
  - upload_completed/fileId (创建标记)

第二次上传（相同文件）：
photo.jpg → 检查 localStorage → 发现已完成
  ↓
前端：调用 POST /merge-chunks 验证
  ↓
后端：
  1. 检查完成标记存在 ✓
  2. 检查实际文件存在 ✓
  3. 返回："文件已上传（跳过重复）"
  ↓
前端：
  - 清理 localStorage
  - 显示："已上传（跳过重复上传）" ✓
```

---

## 常见问题

### Q1: 为什么要用 Worker？
**A**: 图片压缩是耗时操作，在主线程压缩会卡住页面。Worker 在后台线程工作，不影响页面操作。

### Q2: 为什么要 taskId？
**A**: Worker 是单例，多文件同时压缩会混乱。taskId 确保每个文件对应正确的压缩结果。

### Q3: 为什么要保存 _originalFile？
**A**: 压缩后文件信息变了，不同原始文件可能压缩成相同大小。保存原始信息确保 fileId 唯一。

### Q4: 为什么要分块？
**A**: 大文件一次上传，失败了要从头开始。分块上传，失败了只重传失败的块。

### Q5: 为什么要队列？
**A**: 控制并发数，避免同时上传太多文件占用带宽。最多3个文件同时上传。

### Q6: 断点续传不生效？
**A**: 确保选择**完全相同**的文件（不要复制）。复制后 `lastModified` 会变，fileId 就不同了。

### Q7: localStorage 什么时候清理？
**A**: 所有分块上传完成后立即清理，避免刷新页面导致的重复上传问题。

### Q8: 如何测试断点续传？
**A**: 
1. 上传一个大文件
2. 上传到一半时刷新页面（F5）
3. 再次选择同一文件上传
4. 应该看到"发现断点，已上传 X 块"，然后从断点继续

---

## 调试技巧

### 1. 查看控制台日志

```
打开浏览器 → F12 → Console

应该看到：
[photo.jpg] 开始压缩...
[photo.jpg] 压缩完成: 500000 -> 100000 字节
[photo.jpg] 开始上传
[photo.jpg] 文件ID: photo.jpg_500000_1704067200000
[photo.jpg] 总共 1 块，每块 1MB
[photo.jpg] 分块 1/1 上传成功
[photo.jpg] 所有分块上传完成，清理断点记录
[photo.jpg] 开始合并...
[photo.jpg] ✓ 合并完成
```

### 2. 查看 localStorage

```
F12 → Application → Local Storage → http://localhost:5173

应该看到（上传过程中）：
upload_photo.jpg_500000_... : {"chunks":[0,1,2]}

上传完成后会自动清理
```

### 3. 查看网络请求

```
F12 → Network

应该看到：
POST /upload-chunk (多次，每个分块一次)
POST /merge-chunks (1次)
```

---

## 总结

这个上传组件实现了：

1. ✅ **自动压缩**：Worker 后台压缩，不卡页面
2. ✅ **分块上传**：1MB/块，支持大文件
3. ✅ **断点续传**：localStorage 记录进度
4. ✅ **失败重试**：每块重试3次
5. ✅ **并发控制**：最多3个文件同时上传
6. ✅ **重复检测**：避免重复上传
7. ✅ **文件完整性**：双重验证确保数据可靠
8. ✅ **健壮性**：多层容错处理

代码结构清晰，按业务流程组织，易于理解和维护。🎉
